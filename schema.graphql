schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type AboutServerPayload {
  buildTime: LongString!
  buildType: String!
  discord: String!
  github: String!
  name: String!
  revision: String!
  version: String!
}

type AboutWebUI {
  channel: String!
  tag: String!
}

enum BackupRestoreState {
  FAILURE
  IDLE
  RESTORING_CATEGORIES
  RESTORING_MANGA
  SUCCESS
}

type BackupRestoreStatus {
  mangaProgress: Int!
  state: BackupRestoreState!
  totalManga: Int!
}

input BindTrackInput {
  clientMutationId: String
  mangaId: Int!
  remoteId: LongString!
  trackerId: Int!
}

type BindTrackPayload {
  clientMutationId: String
  trackRecord: TrackRecordType!
}

input BooleanFilterInput {
  distinctFrom: Boolean
  equalTo: Boolean
  greaterThan: Boolean
  greaterThanOrEqualTo: Boolean
  in: [Boolean!]
  isNull: Boolean
  lessThan: Boolean
  lessThanOrEqualTo: Boolean
  notDistinctFrom: Boolean
  notEqualTo: Boolean
  notIn: [Boolean!]
}

input CategoryConditionInput {
  default: Boolean
  id: Int
  name: String
  order: Int
}

type CategoryEdge implements Edge {
  cursor: Cursor!
  node: CategoryType!
}

input CategoryFilterInput {
  and: [CategoryFilterInput!]
  default: BooleanFilterInput
  id: IntFilterInput
  name: StringFilterInput
  not: CategoryFilterInput
  or: [CategoryFilterInput!]
  order: IntFilterInput
}

type CategoryMetaType implements MetaType {
  category: CategoryType!
  categoryId: Int!
  key: String!
  value: String!
}

input CategoryMetaTypeInput {
  categoryId: Int!
  key: String!
  value: String!
}

type CategoryNodeList implements NodeList {
  edges: [CategoryEdge!]!
  nodes: [CategoryType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum CategoryOrderBy {
  ID
  NAME
  ORDER
}

type CategoryType {
  default: Boolean!
  id: Int!
  includeInDownload: IncludeOrExclude!
  includeInUpdate: IncludeOrExclude!
  mangas: MangaNodeList!
  meta: [CategoryMetaType!]!
  name: String!
  order: Int!
}

input ChapterConditionInput {
  chapterNumber: Float
  fetchedAt: LongString
  id: Int
  isBookmarked: Boolean
  isDownloaded: Boolean
  isRead: Boolean
  lastPageRead: Int
  lastReadAt: LongString
  mangaId: Int
  name: String
  pageCount: Int
  realUrl: String
  scanlator: String
  sourceOrder: Int
  uploadDate: LongString
  url: String
}

type ChapterEdge implements Edge {
  cursor: Cursor!
  node: ChapterType!
}

input ChapterFilterInput {
  and: [ChapterFilterInput!]
  chapterNumber: FloatFilterInput
  fetchedAt: LongFilterInput
  id: IntFilterInput
  inLibrary: BooleanFilterInput
  isBookmarked: BooleanFilterInput
  isDownloaded: BooleanFilterInput
  isRead: BooleanFilterInput
  lastPageRead: IntFilterInput
  lastReadAt: LongFilterInput
  mangaId: IntFilterInput
  name: StringFilterInput
  not: ChapterFilterInput
  or: [ChapterFilterInput!]
  pageCount: IntFilterInput
  realUrl: StringFilterInput
  scanlator: StringFilterInput
  sourceOrder: IntFilterInput
  uploadDate: LongFilterInput
  url: StringFilterInput
}

type ChapterMetaType implements MetaType {
  chapter: ChapterType!
  chapterId: Int!
  key: String!
  value: String!
}

input ChapterMetaTypeInput {
  chapterId: Int!
  key: String!
  value: String!
}

type ChapterNodeList implements NodeList {
  edges: [ChapterEdge!]!
  nodes: [ChapterType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ChapterOrderBy {
  CHAPTER_NUMBER
  FETCHED_AT
  ID
  LAST_READ_AT
  NAME
  SOURCE_ORDER
  UPLOAD_DATE
}

type ChapterType {
  chapterNumber: Float!
  fetchedAt: LongString!
  id: Int!
  isBookmarked: Boolean!
  isDownloaded: Boolean!
  isRead: Boolean!
  lastPageRead: Int!
  lastReadAt: LongString!
  manga: MangaType!
  mangaId: Int!
  meta: [ChapterMetaType!]!
  name: String!
  pageCount: Int!
  realUrl: String
  scanlator: String
  sourceOrder: Int!
  uploadDate: LongString!
  url: String!
}

type CheckBoxFilter {
  default: Boolean!
  name: String!
}

type CheckBoxPreference {
  currentValue: Boolean
  default: Boolean!
  key: String!
  summary: String
  title: String!
  visible: Boolean!
}

type CheckForServerUpdatesPayload {
  channel: String!
  tag: String!
  url: String!
}

input ClearCachedImagesInput {
  cachedPages: Boolean
  cachedThumbnails: Boolean
  clientMutationId: String
  downloadedThumbnails: Boolean
}

type ClearCachedImagesPayload {
  cachedPages: Boolean
  cachedThumbnails: Boolean
  clientMutationId: String
  downloadedThumbnails: Boolean
}

input ClearDownloaderInput {
  clientMutationId: String
}

type ClearDownloaderPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input CreateBackupInput {
  clientMutationId: String
  includeCategories: Boolean
  includeChapters: Boolean
}

type CreateBackupPayload {
  clientMutationId: String
  url: String!
}

input CreateCategoryInput {
  clientMutationId: String
  default: Boolean
  includeInDownload: IncludeOrExclude
  includeInUpdate: IncludeOrExclude
  name: String!
  order: Int
}

type CreateCategoryPayload {
  category: CategoryType!
  clientMutationId: String
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

input DeleteCategoryInput {
  categoryId: Int!
  clientMutationId: String
}

input DeleteCategoryMetaInput {
  categoryId: Int!
  clientMutationId: String
  key: String!
}

type DeleteCategoryMetaPayload {
  category: CategoryType!
  clientMutationId: String
  meta: CategoryMetaType
}

type DeleteCategoryPayload {
  category: CategoryType
  clientMutationId: String
  mangas: [MangaType!]!
}

input DeleteChapterMetaInput {
  chapterId: Int!
  clientMutationId: String
  key: String!
}

type DeleteChapterMetaPayload {
  chapter: ChapterType!
  clientMutationId: String
  meta: ChapterMetaType
}

input DeleteDownloadedChapterInput {
  clientMutationId: String
  id: Int!
}

type DeleteDownloadedChapterPayload {
  chapters: ChapterType!
  clientMutationId: String
}

input DeleteDownloadedChaptersInput {
  clientMutationId: String
  ids: [Int!]!
}

type DeleteDownloadedChaptersPayload {
  chapters: [ChapterType!]!
  clientMutationId: String
}

input DeleteGlobalMetaInput {
  clientMutationId: String
  key: String!
}

type DeleteGlobalMetaPayload {
  clientMutationId: String
  meta: GlobalMetaType
}

input DeleteMangaMetaInput {
  clientMutationId: String
  key: String!
  mangaId: Int!
}

type DeleteMangaMetaPayload {
  clientMutationId: String
  manga: MangaType!
  meta: MangaMetaType
}

input DeleteSourceMetaInput {
  clientMutationId: String
  key: String!
  sourceId: LongString!
}

type DeleteSourceMetaPayload {
  clientMutationId: String
  meta: SourceMetaType
  source: SourceType
}

input DequeueChapterDownloadInput {
  clientMutationId: String
  id: Int!
}

type DequeueChapterDownloadPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input DequeueChapterDownloadsInput {
  clientMutationId: String
  ids: [Int!]!
}

type DequeueChapterDownloadsPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input DoubleFilterInput {
  distinctFrom: Float
  equalTo: Float
  greaterThan: Float
  greaterThanOrEqualTo: Float
  in: [Float!]
  isNull: Boolean
  lessThan: Float
  lessThanOrEqualTo: Float
  notDistinctFrom: Float
  notEqualTo: Float
  notIn: [Float!]
}

type DownloadEdge implements Edge {
  cursor: Cursor!
  node: DownloadType!
}

type DownloadNodeList implements NodeList {
  edges: [DownloadEdge!]!
  nodes: [DownloadType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum DownloadState {
  DOWNLOADING
  ERROR
  FINISHED
  QUEUED
}

type DownloadStatus {
  queue: [DownloadType!]!
  state: DownloaderState!
}

type DownloadType {
  chapter: ChapterType!
  manga: MangaType!
  progress: Float!
  state: DownloadState!
  tries: Int!
}

enum DownloaderState {
  STARTED
  STOPPED
}

interface Edge {
  """A cursor for use in pagination."""
  cursor: Cursor!
  """The [T] at the end of the edge."""
  node: Node!
}

type EditTextPreference {
  currentValue: String
  default: String
  dialogMessage: String
  dialogTitle: String
  key: String!
  summary: String
  text: String
  title: String
  visible: Boolean!
}

input EnqueueChapterDownloadInput {
  clientMutationId: String
  id: Int!
}

type EnqueueChapterDownloadPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input EnqueueChapterDownloadsInput {
  clientMutationId: String
  ids: [Int!]!
}

type EnqueueChapterDownloadsPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input ExtensionConditionInput {
  apkName: String
  hasUpdate: Boolean
  iconUrl: String
  isInstalled: Boolean
  isNsfw: Boolean
  isObsolete: Boolean
  lang: String
  name: String
  pkgName: String
  repo: String
  versionCode: Int
  versionName: String
}

type ExtensionEdge implements Edge {
  cursor: Cursor!
  node: ExtensionType!
}

input ExtensionFilterInput {
  and: [ExtensionFilterInput!]
  apkName: StringFilterInput
  hasUpdate: BooleanFilterInput
  iconUrl: StringFilterInput
  isInstalled: BooleanFilterInput
  isNsfw: BooleanFilterInput
  isObsolete: BooleanFilterInput
  lang: StringFilterInput
  name: StringFilterInput
  not: ExtensionFilterInput
  or: [ExtensionFilterInput!]
  pkgName: StringFilterInput
  repo: StringFilterInput
  versionCode: IntFilterInput
  versionName: StringFilterInput
}

type ExtensionNodeList implements NodeList {
  edges: [ExtensionEdge!]!
  nodes: [ExtensionType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ExtensionOrderBy {
  APK_NAME
  NAME
  PKG_NAME
}

type ExtensionType {
  apkName: String!
  hasUpdate: Boolean!
  iconUrl: String!
  isInstalled: Boolean!
  isNsfw: Boolean!
  isObsolete: Boolean!
  lang: String!
  name: String!
  pkgName: String!
  repo: String
  source: SourceNodeList!
  versionCode: Int!
  versionName: String!
}

input FetchChapterPagesInput {
  chapterId: Int!
  clientMutationId: String
}

type FetchChapterPagesPayload {
  chapter: ChapterType!
  clientMutationId: String
  pages: [String!]!
}

input FetchChaptersInput {
  clientMutationId: String
  mangaId: Int!
}

type FetchChaptersPayload {
  chapters: [ChapterType!]!
  clientMutationId: String
}

input FetchExtensionsInput {
  clientMutationId: String
}

type FetchExtensionsPayload {
  clientMutationId: String
  extensions: [ExtensionType!]!
}

input FetchMangaInput {
  clientMutationId: String
  id: Int!
}

type FetchMangaPayload {
  clientMutationId: String
  manga: MangaType!
}

input FetchSourceMangaInput {
  clientMutationId: String
  filters: [FilterChangeInput!]
  page: Int!
  query: String
  source: LongString!
  type: FetchSourceMangaType!
}

type FetchSourceMangaPayload {
  clientMutationId: String
  hasNextPage: Boolean!
  mangas: [MangaType!]!
}

enum FetchSourceMangaType {
  LATEST
  POPULAR
  SEARCH
}

input FetchTrackInput {
  clientMutationId: String
  recordId: Int!
}

type FetchTrackPayload {
  clientMutationId: String
  trackRecord: TrackRecordType!
}

union Filter = CheckBoxFilter | GroupFilter | HeaderFilter | SelectFilter | SeparatorFilter | SortFilter | TextFilter | TriStateFilter

input FilterChangeInput {
  checkBoxState: Boolean
  groupChange: FilterChangeInput
  position: Int!
  selectState: Int
  sortState: SortSelectionInput
  textState: String
  triState: TriState
}

input FloatFilterInput {
  distinctFrom: Float
  equalTo: Float
  greaterThan: Float
  greaterThanOrEqualTo: Float
  in: [Float!]
  isNull: Boolean
  lessThan: Float
  lessThanOrEqualTo: Float
  notDistinctFrom: Float
  notEqualTo: Float
  notIn: [Float!]
}

type GlobalMetaNodeList implements NodeList {
  edges: [MetaEdge!]!
  nodes: [GlobalMetaType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type GlobalMetaType implements MetaType {
  key: String!
  value: String!
}

input GlobalMetaTypeInput {
  key: String!
  value: String!
}

type GroupFilter {
  filters: [Filter!]!
  name: String!
}

type HeaderFilter {
  name: String!
}

enum IncludeOrExclude {
  EXCLUDE
  INCLUDE
  UNSET
}

input InstallExternalExtensionInput {
  clientMutationId: String
  extensionFile: Upload!
}

type InstallExternalExtensionPayload {
  clientMutationId: String
  extension: ExtensionType!
}

input IntFilterInput {
  distinctFrom: Int
  equalTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  in: [Int!]
  isNull: Boolean
  lessThan: Int
  lessThanOrEqualTo: Int
  notDistinctFrom: Int
  notEqualTo: Int
  notIn: [Int!]
}

type LastUpdateTimestampPayload {
  timestamp: LongString!
}

type ListPreference {
  currentValue: String
  default: String
  entries: [String!]!
  entryValues: [String!]!
  key: String!
  summary: String
  title: String
  visible: Boolean!
}

input LoginTrackerCredentialsInput {
  clientMutationId: String
  password: String!
  trackerId: Int!
  username: String!
}

type LoginTrackerCredentialsPayload {
  clientMutationId: String
  isLoggedIn: Boolean!
  tracker: TrackerType!
}

input LoginTrackerOAuthInput {
  callbackUrl: String!
  clientMutationId: String
  trackerId: Int!
}

type LoginTrackerOAuthPayload {
  clientMutationId: String
  isLoggedIn: Boolean!
  tracker: TrackerType!
}

input LogoutTrackerInput {
  clientMutationId: String
  trackerId: Int!
}

type LogoutTrackerPayload {
  clientMutationId: String
  isLoggedIn: Boolean!
  tracker: TrackerType!
}

input LongFilterInput {
  distinctFrom: LongString
  equalTo: LongString
  greaterThan: LongString
  greaterThanOrEqualTo: LongString
  in: [LongString!]
  isNull: Boolean
  lessThan: LongString
  lessThanOrEqualTo: LongString
  notDistinctFrom: LongString
  notEqualTo: LongString
  notIn: [LongString!]
}

"""A 64-bit signed integer as a String"""
scalar LongString

input MangaConditionInput {
  artist: String
  author: String
  categoryIds: [Int!]
  chaptersLastFetchedAt: LongString
  description: String
  genre: [String!]
  id: Int
  inLibrary: Boolean
  inLibraryAt: LongString
  initialized: Boolean
  lastFetchedAt: LongString
  realUrl: String
  sourceId: LongString
  status: MangaStatus
  thumbnailUrl: String
  title: String
  url: String
}

type MangaEdge implements Edge {
  cursor: Cursor!
  node: MangaType!
}

input MangaFilterInput {
  and: [MangaFilterInput!]
  artist: StringFilterInput
  author: StringFilterInput
  categoryId: IntFilterInput
  chaptersLastFetchedAt: LongFilterInput
  description: StringFilterInput
  genre: StringFilterInput
  id: IntFilterInput
  inLibrary: BooleanFilterInput
  inLibraryAt: LongFilterInput
  initialized: BooleanFilterInput
  lastFetchedAt: LongFilterInput
  not: MangaFilterInput
  or: [MangaFilterInput!]
  realUrl: StringFilterInput
  sourceId: LongFilterInput
  status: MangaStatusFilterInput
  thumbnailUrl: StringFilterInput
  title: StringFilterInput
  url: StringFilterInput
}

type MangaMetaType implements MetaType {
  key: String!
  manga: MangaType!
  mangaId: Int!
  value: String!
}

input MangaMetaTypeInput {
  key: String!
  mangaId: Int!
  value: String!
}

type MangaNodeList implements NodeList {
  edges: [MangaEdge!]!
  nodes: [MangaType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum MangaOrderBy {
  ID
  IN_LIBRARY_AT
  LAST_FETCHED_AT
  TITLE
}

enum MangaStatus {
  CANCELLED
  COMPLETED
  LICENSED
  ONGOING
  ON_HIATUS
  PUBLISHING_FINISHED
  UNKNOWN
}

input MangaStatusFilterInput {
  distinctFrom: MangaStatus
  equalTo: MangaStatus
  greaterThan: MangaStatus
  greaterThanOrEqualTo: MangaStatus
  in: [MangaStatus!]
  isNull: Boolean
  lessThan: MangaStatus
  lessThanOrEqualTo: MangaStatus
  notDistinctFrom: MangaStatus
  notEqualTo: MangaStatus
  notIn: [MangaStatus!]
}

type MangaType {
  age: LongString
  artist: String
  author: String
  bookmarkCount: Int!
  categories: CategoryNodeList!
  chapters: ChapterNodeList!
  chaptersAge: LongString
  chaptersLastFetchedAt: LongString
  description: String
  downloadCount: Int!
  firstUnreadChapter: ChapterType
  genre: [String!]!
  id: Int!
  inLibrary: Boolean!
  inLibraryAt: LongString!
  initialized: Boolean!
  lastFetchedAt: LongString
  lastReadChapter: ChapterType
  latestFetchedChapter: ChapterType
  latestReadChapter: ChapterType
  latestUploadedChapter: ChapterType
  meta: [MangaMetaType!]!
  realUrl: String
  source: SourceType
  sourceId: LongString!
  status: MangaStatus!
  thumbnailUrl: String
  thumbnailUrlLastFetched: LongString
  title: String!
  trackRecords: TrackRecordNodeList!
  unreadCount: Int!
  updateStrategy: UpdateStrategy!
  url: String!
}

input MetaConditionInput {
  key: String
  value: String
}

type MetaEdge implements Edge {
  cursor: Cursor!
  node: GlobalMetaType!
}

input MetaFilterInput {
  and: [MetaFilterInput!]
  key: StringFilterInput
  not: MetaFilterInput
  or: [MetaFilterInput!]
  value: StringFilterInput
}

enum MetaOrderBy {
  KEY
  VALUE
}

interface MetaType {
  key: String!
  value: String!
}

type MultiSelectListPreference {
  currentValue: [String!]
  default: [String!]
  dialogMessage: String
  dialogTitle: String
  entries: [String!]!
  entryValues: [String!]!
  key: String!
  summary: String
  title: String
  visible: Boolean!
}

type Mutation {
  bindTrack(input: BindTrackInput!): BindTrackPayload!
  clearCachedImages(input: ClearCachedImagesInput!): ClearCachedImagesPayload!
  clearDownloader(input: ClearDownloaderInput!): ClearDownloaderPayload
  createBackup(input: CreateBackupInput): CreateBackupPayload!
  createCategory(input: CreateCategoryInput!): CreateCategoryPayload
  deleteCategory(input: DeleteCategoryInput!): DeleteCategoryPayload
  deleteCategoryMeta(input: DeleteCategoryMetaInput!): DeleteCategoryMetaPayload
  deleteChapterMeta(input: DeleteChapterMetaInput!): DeleteChapterMetaPayload
  deleteDownloadedChapter(input: DeleteDownloadedChapterInput!): DeleteDownloadedChapterPayload
  deleteDownloadedChapters(input: DeleteDownloadedChaptersInput!): DeleteDownloadedChaptersPayload
  deleteGlobalMeta(input: DeleteGlobalMetaInput!): DeleteGlobalMetaPayload
  deleteMangaMeta(input: DeleteMangaMetaInput!): DeleteMangaMetaPayload
  deleteSourceMeta(input: DeleteSourceMetaInput!): DeleteSourceMetaPayload
  dequeueChapterDownload(input: DequeueChapterDownloadInput!): DequeueChapterDownloadPayload
  dequeueChapterDownloads(input: DequeueChapterDownloadsInput!): DequeueChapterDownloadsPayload
  enqueueChapterDownload(input: EnqueueChapterDownloadInput!): EnqueueChapterDownloadPayload
  enqueueChapterDownloads(input: EnqueueChapterDownloadsInput!): EnqueueChapterDownloadsPayload
  fetchChapterPages(input: FetchChapterPagesInput!): FetchChapterPagesPayload
  fetchChapters(input: FetchChaptersInput!): FetchChaptersPayload
  fetchExtensions(input: FetchExtensionsInput!): FetchExtensionsPayload
  fetchManga(input: FetchMangaInput!): FetchMangaPayload
  fetchSourceManga(input: FetchSourceMangaInput!): FetchSourceMangaPayload
  fetchTrack(input: FetchTrackInput!): FetchTrackPayload!
  installExternalExtension(input: InstallExternalExtensionInput!): InstallExternalExtensionPayload
  loginTrackerCredentials(input: LoginTrackerCredentialsInput!): LoginTrackerCredentialsPayload!
  loginTrackerOAuth(input: LoginTrackerOAuthInput!): LoginTrackerOAuthPayload!
  logoutTracker(input: LogoutTrackerInput!): LogoutTrackerPayload!
  reorderChapterDownload(input: ReorderChapterDownloadInput!): ReorderChapterDownloadPayload
  resetSettings(input: ResetSettingsInput!): ResetSettingsPayload!
  resetWebUIUpdateStatus: WebUIUpdateStatus
  restoreBackup(input: RestoreBackupInput!): RestoreBackupPayload!
  setCategoryMeta(input: SetCategoryMetaInput!): SetCategoryMetaPayload
  setChapterMeta(input: SetChapterMetaInput!): SetChapterMetaPayload
  setGlobalMeta(input: SetGlobalMetaInput!): SetGlobalMetaPayload
  setMangaMeta(input: SetMangaMetaInput!): SetMangaMetaPayload
  setSettings(input: SetSettingsInput!): SetSettingsPayload!
  setSourceMeta(input: SetSourceMetaInput!): SetSourceMetaPayload
  startDownloader(input: StartDownloaderInput!): StartDownloaderPayload
  stopDownloader(input: StopDownloaderInput!): StopDownloaderPayload
  trackProgress(input: TrackProgressInput!): TrackProgressPayload
  unbindTrack(input: UnbindTrackInput!): UnbindTrackPayload!
  updateCategories(input: UpdateCategoriesInput!): UpdateCategoriesPayload
  updateCategory(input: UpdateCategoryInput!): UpdateCategoryPayload
  updateCategoryManga(input: UpdateCategoryMangaInput!): UpdateCategoryMangaPayload
  updateCategoryOrder(input: UpdateCategoryOrderInput!): UpdateCategoryOrderPayload
  updateChapter(input: UpdateChapterInput!): UpdateChapterPayload
  updateChapters(input: UpdateChaptersInput!): UpdateChaptersPayload
  updateExtension(input: UpdateExtensionInput!): UpdateExtensionPayload
  updateExtensions(input: UpdateExtensionsInput!): UpdateExtensionsPayload
  updateLibraryManga(input: UpdateLibraryMangaInput!): UpdateLibraryMangaPayload
  updateManga(input: UpdateMangaInput!): UpdateMangaPayload
  updateMangaCategories(input: UpdateMangaCategoriesInput!): UpdateMangaCategoriesPayload
  updateMangas(input: UpdateMangasInput!): UpdateMangasPayload
  updateMangasCategories(input: UpdateMangasCategoriesInput!): UpdateMangasCategoriesPayload
  updateSourcePreference(input: UpdateSourcePreferenceInput!): UpdateSourcePreferencePayload
  updateStop(input: UpdateStopInput!): UpdateStopPayload!
  updateTrack(input: UpdateTrackInput!): UpdateTrackPayload!
  updateWebUI(input: WebUIUpdateInput!): WebUIUpdatePayload
}

union Node = CategoryMetaType | CategoryType | ChapterMetaType | ChapterType | DownloadType | ExtensionType | GlobalMetaType | MangaMetaType | MangaType | PartialSettingsType | SettingsType | SourceMetaType | SourceType | TrackRecordType | TrackerType

interface NodeList {
  """
  A list of edges which contains the [T] and cursor to aid in pagination.
  """
  edges: [Edge!]!
  """A list of [T] objects."""
  nodes: [Node!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of all nodes you could get from the connection."""
  totalCount: Int!
}

type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
}

type PartialSettingsType implements Settings {
  autoDownloadAheadLimit: Int @deprecated(reason: "Replaced with autoDownloadNewChaptersLimit, replace with autoDownloadNewChaptersLimit")
  autoDownloadIgnoreReUploads: Boolean
  autoDownloadNewChapters: Boolean
  autoDownloadNewChaptersLimit: Int
  backupInterval: Int
  backupPath: String
  backupTTL: Int
  backupTime: String
  basicAuthEnabled: Boolean
  basicAuthPassword: String
  basicAuthUsername: String
  debugLogsEnabled: Boolean
  downloadAsCbz: Boolean
  downloadsPath: String
  electronPath: String
  excludeCompleted: Boolean
  excludeEntryWithUnreadChapters: Boolean
  excludeNotStarted: Boolean
  excludeUnreadChapters: Boolean
  extensionRepos: [String!]
  flareSolverrEnabled: Boolean
  flareSolverrSessionName: String
  flareSolverrSessionTtl: Int
  flareSolverrTimeout: Int
  flareSolverrUrl: String
  globalUpdateInterval: Float
  gqlDebugLogsEnabled: Boolean
  initialOpenInBrowserEnabled: Boolean
  ip: String
  localSourcePath: String
  maxSourcesInParallel: Int
  port: Int
  socksProxyEnabled: Boolean
  socksProxyHost: String
  socksProxyPassword: String
  socksProxyPort: String
  socksProxyUsername: String
  socksProxyVersion: Int
  systemTrayEnabled: Boolean
  updateMangas: Boolean
  webUIChannel: WebUIChannel
  webUIFlavor: WebUIFlavor
  webUIInterface: WebUIInterface
  webUIUpdateCheckInterval: Float
}

input PartialSettingsTypeInput {
  autoDownloadIgnoreReUploads: Boolean
  autoDownloadNewChapters: Boolean
  autoDownloadNewChaptersLimit: Int
  backupInterval: Int
  backupPath: String
  backupTTL: Int
  backupTime: String
  basicAuthEnabled: Boolean
  basicAuthPassword: String
  basicAuthUsername: String
  debugLogsEnabled: Boolean
  downloadAsCbz: Boolean
  downloadsPath: String
  electronPath: String
  excludeCompleted: Boolean
  excludeEntryWithUnreadChapters: Boolean
  excludeNotStarted: Boolean
  excludeUnreadChapters: Boolean
  extensionRepos: [String!]
  flareSolverrEnabled: Boolean
  flareSolverrSessionName: String
  flareSolverrSessionTtl: Int
  flareSolverrTimeout: Int
  flareSolverrUrl: String
  globalUpdateInterval: Float
  gqlDebugLogsEnabled: Boolean
  initialOpenInBrowserEnabled: Boolean
  ip: String
  localSourcePath: String
  maxSourcesInParallel: Int
  port: Int
  socksProxyEnabled: Boolean
  socksProxyHost: String
  socksProxyPassword: String
  socksProxyPort: String
  socksProxyUsername: String
  socksProxyVersion: Int
  systemTrayEnabled: Boolean
  updateMangas: Boolean
  webUIChannel: WebUIChannel
  webUIFlavor: WebUIFlavor
  webUIInterface: WebUIInterface
  webUIUpdateCheckInterval: Float
}

union Preference = CheckBoxPreference | EditTextPreference | ListPreference | MultiSelectListPreference | SwitchPreference

type Query {
  aboutServer: AboutServerPayload!
  aboutWebUI: AboutWebUI!
  categories(after: Cursor, before: Cursor, condition: CategoryConditionInput, filter: CategoryFilterInput, first: Int, last: Int, offset: Int, orderBy: CategoryOrderBy, orderByType: SortOrder): CategoryNodeList!
  category(id: Int!): CategoryType!
  chapter(id: Int!): ChapterType!
  chapters(after: Cursor, before: Cursor, condition: ChapterConditionInput, filter: ChapterFilterInput, first: Int, last: Int, offset: Int, orderBy: ChapterOrderBy, orderByType: SortOrder): ChapterNodeList!
  checkForServerUpdates: [CheckForServerUpdatesPayload!]!
  checkForWebUIUpdate: WebUIUpdateCheck!
  downloadStatus: DownloadStatus!
  extension(pkgName: String!): ExtensionType!
  extensions(after: Cursor, before: Cursor, condition: ExtensionConditionInput, filter: ExtensionFilterInput, first: Int, last: Int, offset: Int, orderBy: ExtensionOrderBy, orderByType: SortOrder): ExtensionNodeList!
  getWebUIUpdateStatus: WebUIUpdateStatus!
  lastUpdateTimestamp: LastUpdateTimestampPayload!
  manga(id: Int!): MangaType!
  mangas(after: Cursor, before: Cursor, condition: MangaConditionInput, filter: MangaFilterInput, first: Int, last: Int, offset: Int, orderBy: MangaOrderBy, orderByType: SortOrder): MangaNodeList!
  meta(key: String!): GlobalMetaType!
  metas(after: Cursor, before: Cursor, condition: MetaConditionInput, filter: MetaFilterInput, first: Int, last: Int, offset: Int, orderBy: MetaOrderBy, orderByType: SortOrder): GlobalMetaNodeList!
  restoreStatus(id: String!): BackupRestoreStatus
  searchTracker(input: SearchTrackerInput!): SearchTrackerPayload!
  settings: SettingsType!
  source(id: LongString!): SourceType!
  sources(after: Cursor, before: Cursor, condition: SourceConditionInput, filter: SourceFilterInput, first: Int, last: Int, offset: Int, orderBy: SourceOrderBy, orderByType: SortOrder): SourceNodeList!
  trackRecord(id: Int!): TrackRecordType!
  trackRecords(after: Cursor, before: Cursor, condition: TrackRecordConditionInput, filter: TrackRecordFilterInput, first: Int, last: Int, offset: Int, orderBy: TrackRecordOrderBy, orderByType: SortOrder): TrackRecordNodeList!
  tracker(id: Int!): TrackerType!
  trackers(after: Cursor, before: Cursor, condition: TrackerConditionInput, first: Int, last: Int, offset: Int, orderBy: TrackerOrderBy, orderByType: SortOrder): TrackerNodeList!
  updateStatus: UpdateStatus!
  validateBackup(input: ValidateBackupInput!): ValidateBackupResult!
}

input ReorderChapterDownloadInput {
  chapterId: Int!
  clientMutationId: String
  to: Int!
}

type ReorderChapterDownloadPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input ResetSettingsInput {
  clientMutationId: String
}

type ResetSettingsPayload {
  clientMutationId: String
  settings: SettingsType!
}

input RestoreBackupInput {
  backup: Upload!
  clientMutationId: String
}

type RestoreBackupPayload {
  clientMutationId: String
  id: String!
  status: BackupRestoreStatus
}

input SearchTrackerInput {
  query: String!
  trackerId: Int!
}

type SearchTrackerPayload {
  trackSearches: [TrackSearchType!]!
}

type SelectFilter {
  default: Int!
  name: String!
  values: [String!]!
}

type SeparatorFilter {
  name: String!
}

input SetCategoryMetaInput {
  clientMutationId: String
  meta: CategoryMetaTypeInput!
}

type SetCategoryMetaPayload {
  clientMutationId: String
  meta: CategoryMetaType!
}

input SetChapterMetaInput {
  clientMutationId: String
  meta: ChapterMetaTypeInput!
}

type SetChapterMetaPayload {
  clientMutationId: String
  meta: ChapterMetaType!
}

input SetGlobalMetaInput {
  clientMutationId: String
  meta: GlobalMetaTypeInput!
}

type SetGlobalMetaPayload {
  clientMutationId: String
  meta: GlobalMetaType!
}

input SetMangaMetaInput {
  clientMutationId: String
  meta: MangaMetaTypeInput!
}

type SetMangaMetaPayload {
  clientMutationId: String
  meta: MangaMetaType!
}

input SetSettingsInput {
  clientMutationId: String
  settings: PartialSettingsTypeInput!
}

type SetSettingsPayload {
  clientMutationId: String
  settings: SettingsType!
}

input SetSourceMetaInput {
  clientMutationId: String
  meta: SourceMetaTypeInput!
}

type SetSourceMetaPayload {
  clientMutationId: String
  meta: SourceMetaType!
}

interface Settings {
  autoDownloadAheadLimit: Int @deprecated(reason: "Replaced with autoDownloadNewChaptersLimit, replace with autoDownloadNewChaptersLimit")
  autoDownloadIgnoreReUploads: Boolean
  autoDownloadNewChapters: Boolean
  autoDownloadNewChaptersLimit: Int
  backupInterval: Int
  backupPath: String
  backupTTL: Int
  backupTime: String
  basicAuthEnabled: Boolean
  basicAuthPassword: String
  basicAuthUsername: String
  debugLogsEnabled: Boolean
  downloadAsCbz: Boolean
  downloadsPath: String
  electronPath: String
  excludeCompleted: Boolean
  excludeEntryWithUnreadChapters: Boolean
  excludeNotStarted: Boolean
  excludeUnreadChapters: Boolean
  extensionRepos: [String!]
  flareSolverrEnabled: Boolean
  flareSolverrSessionName: String
  flareSolverrSessionTtl: Int
  flareSolverrTimeout: Int
  flareSolverrUrl: String
  globalUpdateInterval: Float
  gqlDebugLogsEnabled: Boolean
  initialOpenInBrowserEnabled: Boolean
  ip: String
  localSourcePath: String
  maxSourcesInParallel: Int
  port: Int
  socksProxyEnabled: Boolean
  socksProxyHost: String
  socksProxyPassword: String
  socksProxyPort: String
  socksProxyUsername: String
  socksProxyVersion: Int
  systemTrayEnabled: Boolean
  updateMangas: Boolean
  webUIChannel: WebUIChannel
  webUIFlavor: WebUIFlavor
  webUIInterface: WebUIInterface
  webUIUpdateCheckInterval: Float
}

type SettingsType implements Settings {
  autoDownloadAheadLimit: Int! @deprecated(reason: "Replaced with autoDownloadNewChaptersLimit, replace with autoDownloadNewChaptersLimit")
  autoDownloadIgnoreReUploads: Boolean
  autoDownloadNewChapters: Boolean!
  autoDownloadNewChaptersLimit: Int!
  backupInterval: Int!
  backupPath: String!
  backupTTL: Int!
  backupTime: String!
  basicAuthEnabled: Boolean!
  basicAuthPassword: String!
  basicAuthUsername: String!
  debugLogsEnabled: Boolean!
  downloadAsCbz: Boolean!
  downloadsPath: String!
  electronPath: String!
  excludeCompleted: Boolean!
  excludeEntryWithUnreadChapters: Boolean!
  excludeNotStarted: Boolean!
  excludeUnreadChapters: Boolean!
  extensionRepos: [String!]!
  flareSolverrEnabled: Boolean!
  flareSolverrSessionName: String!
  flareSolverrSessionTtl: Int!
  flareSolverrTimeout: Int!
  flareSolverrUrl: String!
  globalUpdateInterval: Float!
  gqlDebugLogsEnabled: Boolean!
  initialOpenInBrowserEnabled: Boolean!
  ip: String!
  localSourcePath: String!
  maxSourcesInParallel: Int!
  port: Int!
  socksProxyEnabled: Boolean!
  socksProxyHost: String!
  socksProxyPassword: String!
  socksProxyPort: String!
  socksProxyUsername: String!
  socksProxyVersion: Int!
  systemTrayEnabled: Boolean!
  updateMangas: Boolean!
  webUIChannel: WebUIChannel!
  webUIFlavor: WebUIFlavor!
  webUIInterface: WebUIInterface!
  webUIUpdateCheckInterval: Float!
}

type SortFilter {
  default: SortSelection
  name: String!
  values: [String!]!
}

enum SortOrder {
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
}

type SortSelection {
  ascending: Boolean!
  index: Int!
}

input SortSelectionInput {
  ascending: Boolean!
  index: Int!
}

input SourceConditionInput {
  id: LongString
  isNsfw: Boolean
  lang: String
  name: String
}

type SourceEdge implements Edge {
  cursor: Cursor!
  node: SourceType!
}

input SourceFilterInput {
  and: [SourceFilterInput!]
  id: LongFilterInput
  isNsfw: BooleanFilterInput
  lang: StringFilterInput
  name: StringFilterInput
  not: SourceFilterInput
  or: [SourceFilterInput!]
}

type SourceMetaType implements MetaType {
  key: String!
  source: SourceType!
  sourceId: LongString!
  value: String!
}

input SourceMetaTypeInput {
  key: String!
  sourceId: LongString!
  value: String!
}

type SourceNodeList implements NodeList {
  edges: [SourceEdge!]!
  nodes: [SourceType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum SourceOrderBy {
  ID
  LANG
  NAME
}

input SourcePreferenceChangeInput {
  checkBoxState: Boolean
  editTextState: String
  listState: String
  multiSelectState: [String!]
  position: Int!
  switchState: Boolean
}

type SourceType {
  displayName: String!
  extension: ExtensionType!
  filters: [Filter!]!
  iconUrl: String!
  id: LongString!
  isConfigurable: Boolean!
  isNsfw: Boolean!
  lang: String!
  manga: MangaNodeList!
  meta: [SourceMetaType!]!
  name: String!
  preferences: [Preference!]!
  supportsLatest: Boolean!
}

input StartDownloaderInput {
  clientMutationId: String
}

type StartDownloaderPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input StopDownloaderInput {
  clientMutationId: String
}

type StopDownloaderPayload {
  clientMutationId: String
  downloadStatus: DownloadStatus!
}

input StringFilterInput {
  distinctFrom: String
  distinctFromInsensitive: String
  endsWith: String
  endsWithInsensitive: String
  equalTo: String
  greaterThan: String
  greaterThanInsensitive: String
  greaterThanOrEqualTo: String
  greaterThanOrEqualToInsensitive: String
  in: [String!]
  inInsensitive: [String!]
  includes: String
  includesInsensitive: String
  isNull: Boolean
  lessThan: String
  lessThanInsensitive: String
  lessThanOrEqualTo: String
  lessThanOrEqualToInsensitive: String
  like: String
  likeInsensitive: String
  notDistinctFrom: String
  notDistinctFromInsensitive: String
  notEndsWith: String
  notEndsWithInsensitive: String
  notEqualTo: String
  notIn: [String!]
  notInInsensitive: [String!]
  notIncludes: String
  notIncludesInsensitive: String
  notLike: String
  notLikeInsensitive: String
  notStartsWith: String
  notStartsWithInsensitive: String
  startsWith: String
  startsWithInsensitive: String
}

type Subscription {
  downloadChanged: DownloadStatus!
  updateStatusChanged: UpdateStatus!
  webUIUpdateStatusChange: WebUIUpdateStatus!
}

type SwitchPreference {
  currentValue: Boolean
  default: Boolean!
  key: String!
  summary: String
  title: String!
  visible: Boolean!
}

type TextFilter {
  default: String!
  name: String!
}

input TrackProgressInput {
  clientMutationId: String
  mangaId: Int!
}

type TrackProgressPayload {
  clientMutationId: String
  trackRecords: [TrackRecordType!]!
}

input TrackRecordConditionInput {
  finishDate: LongString
  id: Int
  lastChapterRead: Float
  libraryId: LongString
  mangaId: Int
  remoteId: LongString
  remoteUrl: String
  score: Float
  startDate: LongString
  status: Int
  title: String
  totalChapters: Int
  trackerId: Int
}

type TrackRecordEdge implements Edge {
  cursor: Cursor!
  node: TrackRecordType!
}

input TrackRecordFilterInput {
  and: [TrackRecordFilterInput!]
  finishDate: LongFilterInput
  id: IntFilterInput
  lastChapterRead: DoubleFilterInput
  libraryId: LongFilterInput
  mangaId: IntFilterInput
  not: TrackRecordFilterInput
  or: [TrackRecordFilterInput!]
  remoteId: LongFilterInput
  remoteUrl: StringFilterInput
  score: DoubleFilterInput
  startDate: LongFilterInput
  status: IntFilterInput
  title: StringFilterInput
  totalChapters: IntFilterInput
  trackerId: IntFilterInput
}

type TrackRecordNodeList implements NodeList {
  edges: [TrackRecordEdge!]!
  nodes: [TrackRecordType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum TrackRecordOrderBy {
  FINISH_DATE
  ID
  LAST_CHAPTER_READ
  MANGA_ID
  REMOTE_ID
  SCORE
  START_DATE
  TITLE
  TOTAL_CHAPTERS
  TRACKER_ID
}

type TrackRecordType {
  displayScore: String!
  finishDate: LongString!
  id: Int!
  lastChapterRead: Float!
  libraryId: LongString
  manga: MangaType!
  mangaId: Int!
  remoteId: LongString!
  remoteUrl: String!
  score: Float!
  startDate: LongString!
  status: Int!
  title: String!
  totalChapters: Int!
  tracker: TrackerType!
  trackerId: Int!
}

type TrackSearchType {
  coverUrl: String!
  id: Int!
  publishingStatus: String!
  publishingType: String!
  remoteId: LongString!
  startDate: String!
  summary: String!
  title: String!
  totalChapters: Int!
  tracker: TrackerType!
  trackerId: Int!
  trackingUrl: String!
}

type TrackStatusType {
  name: String!
  value: Int!
}

input TrackerConditionInput {
  icon: String
  id: Int
  isLoggedIn: Boolean
  name: String
}

type TrackerEdge implements Edge {
  cursor: Cursor!
  node: TrackerType!
}

type TrackerNodeList implements NodeList {
  edges: [TrackerEdge!]!
  nodes: [TrackerType!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

enum TrackerOrderBy {
  ID
  IS_LOGGED_IN
  NAME
}

type TrackerType {
  authUrl: String
  icon: String!
  id: Int!
  isLoggedIn: Boolean!
  isTokenExpired: Boolean!
  name: String!
  scores: [String!]!
  statuses: [TrackStatusType!]!
  supportsTrackDeletion: Boolean
  trackRecords: TrackRecordNodeList!
}

enum TriState {
  EXCLUDE
  IGNORE
  INCLUDE
}

type TriStateFilter {
  default: TriState!
  name: String!
}

input UnbindTrackInput {
  clientMutationId: String
  """
  This will only work if the tracker of the track record supports deleting tracks
  """
  deleteRemoteTrack: Boolean
  recordId: Int!
}

type UnbindTrackPayload {
  clientMutationId: String
  trackRecord: TrackRecordType
}

input UpdateCategoriesInput {
  clientMutationId: String
  ids: [Int!]!
  patch: UpdateCategoryPatchInput!
}

type UpdateCategoriesPayload {
  categories: [CategoryType!]!
  clientMutationId: String
}

input UpdateCategoryInput {
  clientMutationId: String
  id: Int!
  patch: UpdateCategoryPatchInput!
}

input UpdateCategoryMangaInput {
  categories: [Int!]!
  clientMutationId: String
}

type UpdateCategoryMangaPayload {
  clientMutationId: String
  updateStatus: UpdateStatus!
}

input UpdateCategoryOrderInput {
  clientMutationId: String
  id: Int!
  position: Int!
}

type UpdateCategoryOrderPayload {
  categories: [CategoryType!]!
  clientMutationId: String
}

input UpdateCategoryPatchInput {
  default: Boolean
  includeInDownload: IncludeOrExclude
  includeInUpdate: IncludeOrExclude
  name: String
}

type UpdateCategoryPayload {
  category: CategoryType!
  clientMutationId: String
}

input UpdateChapterInput {
  clientMutationId: String
  id: Int!
  patch: UpdateChapterPatchInput!
}

input UpdateChapterPatchInput {
  isBookmarked: Boolean
  isRead: Boolean
  lastPageRead: Int
}

type UpdateChapterPayload {
  chapter: ChapterType!
  clientMutationId: String
}

input UpdateChaptersInput {
  clientMutationId: String
  ids: [Int!]!
  patch: UpdateChapterPatchInput!
}

type UpdateChaptersPayload {
  chapters: [ChapterType!]!
  clientMutationId: String
}

input UpdateExtensionInput {
  clientMutationId: String
  id: String!
  patch: UpdateExtensionPatchInput!
}

input UpdateExtensionPatchInput {
  install: Boolean
  uninstall: Boolean
  update: Boolean
}

type UpdateExtensionPayload {
  clientMutationId: String
  extension: ExtensionType
}

input UpdateExtensionsInput {
  clientMutationId: String
  ids: [String!]!
  patch: UpdateExtensionPatchInput!
}

type UpdateExtensionsPayload {
  clientMutationId: String
  extensions: [ExtensionType!]!
}

input UpdateLibraryMangaInput {
  clientMutationId: String
}

type UpdateLibraryMangaPayload {
  clientMutationId: String
  updateStatus: UpdateStatus!
}

input UpdateMangaCategoriesInput {
  clientMutationId: String
  id: Int!
  patch: UpdateMangaCategoriesPatchInput!
}

input UpdateMangaCategoriesPatchInput {
  addToCategories: [Int!]
  clearCategories: Boolean
  removeFromCategories: [Int!]
}

type UpdateMangaCategoriesPayload {
  clientMutationId: String
  manga: MangaType!
}

input UpdateMangaInput {
  clientMutationId: String
  id: Int!
  patch: UpdateMangaPatchInput!
}

input UpdateMangaPatchInput {
  inLibrary: Boolean
}

type UpdateMangaPayload {
  clientMutationId: String
  manga: MangaType!
}

input UpdateMangasCategoriesInput {
  clientMutationId: String
  ids: [Int!]!
  patch: UpdateMangaCategoriesPatchInput!
}

type UpdateMangasCategoriesPayload {
  clientMutationId: String
  mangas: [MangaType!]!
}

input UpdateMangasInput {
  clientMutationId: String
  ids: [Int!]!
  patch: UpdateMangaPatchInput!
}

type UpdateMangasPayload {
  clientMutationId: String
  mangas: [MangaType!]!
}

input UpdateSourcePreferenceInput {
  change: SourcePreferenceChangeInput!
  clientMutationId: String
  source: LongString!
}

type UpdateSourcePreferencePayload {
  clientMutationId: String
  preferences: [Preference!]!
  source: SourceType!
}

enum UpdateState {
  DOWNLOADING
  ERROR
  FINISHED
  IDLE
}

type UpdateStatus {
  completeJobs: UpdateStatusType!
  failedJobs: UpdateStatusType!
  isRunning: Boolean!
  pendingJobs: UpdateStatusType!
  runningJobs: UpdateStatusType!
  skippedCategories: UpdateStatusCategoryType!
  skippedJobs: UpdateStatusType!
  updatingCategories: UpdateStatusCategoryType!
}

type UpdateStatusCategoryType {
  categories: CategoryNodeList!
}

type UpdateStatusType {
  mangas: MangaNodeList!
}

input UpdateStopInput {
  clientMutationId: String
}

type UpdateStopPayload {
  clientMutationId: String
}

enum UpdateStrategy {
  ALWAYS_UPDATE
  ONLY_FETCH_ONCE
}

input UpdateTrackInput {
  clientMutationId: String
  finishDate: LongString
  lastChapterRead: Float
  recordId: Int!
  scoreString: String
  startDate: LongString
  status: Int
}

type UpdateTrackPayload {
  clientMutationId: String
  trackRecord: TrackRecordType
}

"""A file part in a multipart request"""
scalar Upload

input ValidateBackupInput {
  backup: Upload!
}

type ValidateBackupResult {
  missingSources: [ValidateBackupSource!]!
  missingTrackers: [ValidateBackupTracker!]!
}

type ValidateBackupSource {
  id: LongString!
  name: String!
}

type ValidateBackupTracker {
  name: String!
}

enum WebUIChannel {
  BUNDLED
  PREVIEW
  STABLE
}

enum WebUIFlavor {
  CUSTOM
  VUI
  WEBUI
}

enum WebUIInterface {
  BROWSER
  ELECTRON
}

type WebUIUpdateCheck {
  channel: String!
  tag: String!
  updateAvailable: Boolean!
}

type WebUIUpdateInfo {
  channel: String!
  tag: String!
}

input WebUIUpdateInput {
  clientMutationId: String
}

type WebUIUpdatePayload {
  clientMutationId: String
  updateStatus: WebUIUpdateStatus!
}

type WebUIUpdateStatus {
  info: WebUIUpdateInfo!
  progress: Int!
  state: UpdateState!
}